<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IndexerGroup.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fcrepo-jms-indexer-core</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.indexer</a> &gt; <span class="el_source">IndexerGroup.java</span></div><h1>IndexerGroup.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2014 DuraSpace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.indexer;

import com.google.common.base.Supplier;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.NodeIterator;
import com.hp.hpl.jena.rdf.model.Property;
import com.hp.hpl.jena.rdf.model.Resource;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.client.DefaultRedirectStrategy;
import org.apache.http.impl.client.StandardHttpRequestRetryHandler;
import org.apache.http.impl.conn.PoolingClientConnectionManager;
import org.fcrepo.kernel.utils.EventType;
import org.slf4j.Logger;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import java.io.Reader;
import java.net.URI;
import java.util.HashSet;
import java.util.Set;

import static com.google.common.base.Suppliers.memoize;
import static com.google.common.base.Throwables.propagate;
import static com.hp.hpl.jena.rdf.model.ResourceFactory.createProperty;
import static com.hp.hpl.jena.rdf.model.ResourceFactory.createResource;
import static com.hp.hpl.jena.vocabulary.RDF.type;
import static java.lang.Integer.MAX_VALUE;
import static javax.jcr.observation.Event.NODE_REMOVED;
import static org.apache.commons.lang.StringUtils.isBlank;
import static org.fcrepo.kernel.RdfLexicon.HAS_CHILD;
import static org.fcrepo.kernel.RdfLexicon.REPOSITORY_NAMESPACE;
import static org.fcrepo.kernel.RdfLexicon.RESTAPI_NAMESPACE;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * MessageListener implementation that retrieves objects from the repository and
 * invokes one or more indexers to index the content. documentation:
 * https://wiki.duraspace.org/display/FF/Design+-+Messaging+for+Workflow
 *
 * @author Esm√© Cowles
 * @author ajs6f
 * @date Aug 19 2013
 **/
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">public class IndexerGroup implements MessageListener {</span>

<span class="fc" id="L66">    private static final Logger LOGGER = getLogger(IndexerGroup.class);</span>

    private final String repositoryURL;

    private final Set&lt;Indexer&lt;Object&gt;&gt; indexers;

    private final DefaultHttpClient httpClient;

    private Set&lt;String&gt; reindexed;

    /**
     * Identifier message header
     */
    static final String IDENTIFIER_HEADER_NAME = REPOSITORY_NAMESPACE
            + &quot;identifier&quot;;

    /**
     * Properties message header
     */
    static final String PROPERTIES_HEADER_NAME = REPOSITORY_NAMESPACE + &quot;properties&quot;;

    /**
     * BaseURL message header
     */
    static final String BASE_URL_HEADER_NAME = REPOSITORY_NAMESPACE + &quot;baseURL&quot;;

    /**
     * Event type message header
     */
    static final String EVENT_TYPE_HEADER_NAME = REPOSITORY_NAMESPACE
            + &quot;eventType&quot;;

    /**
     * Type of event that qualifies as a removal.
     */
<span class="fc" id="L101">    static final String REMOVAL_EVENT_TYPE = REPOSITORY_NAMESPACE</span>
            + EventType.valueOf(NODE_REMOVED).toString();

    /**
     * Type of event to indicate reindexing.
     */
    private static final String REINDEX_EVENT_TYPE = REPOSITORY_NAMESPACE
            + &quot;NODE_REINDEXED&quot;;

    public static final String INDEXER_NAMESPACE =
        &quot;http://fedora.info/definitions/v4/indexing#&quot;;

    /**
     * Indicates the transformation to use with this resource to derive indexing
     * information.
     */
<span class="fc" id="L117">    public static final Property INDEXING_TRANSFORM_PREDICATE =</span>
        createProperty(INDEXER_NAMESPACE + &quot;hasIndexingTransformation&quot;);

    /**
     * Indicates that a resource is indexable.
     */
<span class="fc" id="L123">    public static final Resource INDEXABLE_MIXIN =</span>
        createResource(INDEXER_NAMESPACE + &quot;indexable&quot;);

    /**
     * Indicates that a resource is a datastream.
    **/
<span class="fc" id="L129">    static final Resource DATASTREAM_TYPE = createResource(RESTAPI_NAMESPACE + &quot;datastream&quot;);</span>

<span class="fc" id="L131">    private static final Reader EMPTY_CONTENT = null;</span>

    /**
     * Default constructor.
     **/
    public IndexerGroup(final String repositoryURL,
                        final Set&lt;Indexer&lt;Object&gt;&gt; indexers,
                        final String fedoraUsername,
                        final String fedoraPassword) {
<span class="fc" id="L140">        this(repositoryURL, indexers, createHttpClient(repositoryURL, fedoraUsername, fedoraPassword));</span>
<span class="fc" id="L141">    }</span>

    protected static DefaultHttpClient createHttpClient(final String repositoryURL,
                                                      final String fedoraUsername,
                                                      final String fedoraPassword) {
<span class="fc" id="L146">        final PoolingClientConnectionManager connMann = new PoolingClientConnectionManager();</span>
<span class="fc" id="L147">        connMann.setMaxTotal(MAX_VALUE);</span>
<span class="fc" id="L148">        connMann.setDefaultMaxPerRoute(MAX_VALUE);</span>

<span class="fc" id="L150">        final DefaultHttpClient httpClient = new DefaultHttpClient(connMann);</span>
<span class="fc" id="L151">        httpClient.setRedirectStrategy(new DefaultRedirectStrategy());</span>
<span class="fc" id="L152">        httpClient.setHttpRequestRetryHandler(new StandardHttpRequestRetryHandler(0, false));</span>

        // If the Fedora instance requires authentication, set it up here
<span class="pc bpc" id="L155" title="3 of 4 branches missed.">        if (!isBlank(fedoraUsername) &amp;&amp; !isBlank(fedoraPassword)) {</span>
<span class="nc" id="L156">            LOGGER.debug(&quot;Adding BASIC credentials to client for repo requests.&quot;);</span>

<span class="nc" id="L158">            final URI fedoraUri = URI.create(repositoryURL);</span>
<span class="nc" id="L159">            final CredentialsProvider credsProvider = new BasicCredentialsProvider();</span>
<span class="nc" id="L160">            credsProvider.setCredentials(new AuthScope(fedoraUri.getHost(), fedoraUri.getPort()),</span>
                                         new UsernamePasswordCredentials(fedoraUsername, fedoraPassword));

<span class="nc" id="L163">            httpClient.setCredentialsProvider(credsProvider);</span>
        }

<span class="fc" id="L166">        return httpClient;</span>
    }

    /**
     * Constructor
     */
    public IndexerGroup(final String repositoryURL,
                        final Set&lt;Indexer&lt;Object&gt;&gt; indexers,
<span class="fc" id="L174">                        final DefaultHttpClient httpClient) {</span>
<span class="fc" id="L175">        LOGGER.debug(&quot;Creating IndexerGroup: {}&quot;, this);</span>

<span class="pc bpc" id="L177" title="2 of 4 branches missed.">        assert (null != repositoryURL);</span>
<span class="fc" id="L178">        this.repositoryURL = repositoryURL;</span>

<span class="pc bpc" id="L180" title="2 of 4 branches missed.">        assert (indexers.size() &gt; 0);</span>
<span class="fc" id="L181">        this.indexers = indexers;</span>

<span class="pc bpc" id="L183" title="2 of 4 branches missed.">        assert (null != httpClient);</span>
<span class="fc" id="L184">        this.httpClient = httpClient;</span>
<span class="fc" id="L185">    }</span>

    /**
     * Get repository URL.
     **/
    public String getRepositoryURL() {
<span class="fc" id="L191">        return repositoryURL;</span>
    }

    /**
     * Handle a JMS message representing an object update or deletion event.
     **/
    @Override
    public void onMessage(final Message message) {
        try {
<span class="fc" id="L200">            LOGGER.debug(&quot;Received message: {}&quot;, message.getJMSMessageID());</span>
<span class="nc" id="L201">        } catch (final JMSException e) {</span>
<span class="nc" id="L202">            LOGGER.error(&quot;Received unintelligible message: {}&quot;, e);</span>
<span class="nc" id="L203">            propagate(e);</span>
<span class="fc" id="L204">        }</span>
        try {
            // get id and eventType from message
<span class="fc" id="L207">            final String eventType =</span>
                message.getStringProperty(EVENT_TYPE_HEADER_NAME);
<span class="fc" id="L209">            final String id = message.getStringProperty(IDENTIFIER_HEADER_NAME);</span>
<span class="fc" id="L210">            final String baseURL = message.getStringProperty(BASE_URL_HEADER_NAME);</span>

<span class="fc" id="L212">            LOGGER.debug(&quot;Discovered id: {} in message.&quot;, id);</span>
<span class="fc" id="L213">            LOGGER.debug(&quot;Discovered event type: {} in message.&quot;, eventType);</span>
<span class="fc" id="L214">            LOGGER.debug(&quot;Discovered baseURL: {} in message.&quot;, baseURL);</span>
<span class="fc" id="L215">            LOGGER.debug(&quot;Discovered properties: {} in message.&quot;, message.getStringProperty(PROPERTIES_HEADER_NAME));</span>

<span class="fc" id="L217">            index( baseURL + id, eventType );</span>
<span class="nc" id="L218">        } catch (final JMSException e) {</span>
<span class="nc" id="L219">            LOGGER.error(&quot;Error processing JMS event!&quot;, e);</span>
<span class="fc" id="L220">        }</span>
<span class="fc" id="L221">    }</span>

    /**
     * Index a resource.
    **/
    private void index( final String uri, final String eventType ) {
<span class="fc" id="L227">        final Boolean removal = REMOVAL_EVENT_TYPE.equals(eventType);</span>
<span class="fc" id="L228">        LOGGER.debug(&quot;It is {} that this is a removal operation.&quot;, removal);</span>
<span class="fc" id="L229">        final Supplier&lt;Model&gt; rdfr =</span>
            memoize(new RdfRetriever(uri, httpClient));
<span class="fc" id="L231">        final Supplier&lt;NamedFields&gt; nfr =</span>
            memoize(new NamedFieldsRetriever(uri, httpClient, rdfr));
<span class="fc" id="L233">        Boolean indexable = false;</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">        if (!removal) {</span>
<span class="fc" id="L236">            final Model rdf = rdfr.get();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (rdf.contains(createResource(uri), type, INDEXABLE_MIXIN)) {</span>
<span class="fc" id="L238">                LOGGER.debug(&quot;Resource: {} retrieved with indexable type.&quot;,</span>
                        uri);
<span class="fc" id="L240">                indexable = true;</span>
            } else {
<span class="fc" id="L242">                LOGGER.debug(</span>
                        &quot;Resource: {} retrieved without indexable type.&quot;,
                        uri);
            }

            // if this is a datastream, also index the parent object
<span class="pc bpc" id="L248" title="1 of 4 branches missed.">            if (rdf.contains(createResource(uri), type, DATASTREAM_TYPE) &amp;&amp; uri.indexOf(&quot;/fedora:system/&quot;) == -1 ) {</span>
<span class="nc" id="L249">                final String parent = uri.substring(0, uri.lastIndexOf(&quot;/&quot;));</span>
<span class="nc" id="L250">                LOGGER.info(&quot;Datastream found, also indexing parent {}&quot;, parent);</span>
<span class="nc" id="L251">                index( parent, &quot;NODE_UPDATED&quot;);</span>
            }
        }

<span class="fc bfc" id="L255" title="All 2 branches covered.">        for (final Indexer&lt;Object&gt; indexer : indexers) {</span>
<span class="fc" id="L256">            LOGGER.debug(&quot;Operating for indexer: {}&quot;, indexer);</span>
<span class="fc" id="L257">            Boolean hasContent = false;</span>
<span class="fc" id="L258">            Object content = EMPTY_CONTENT;</span>
<span class="fc bfc" id="L259" title="All 4 branches covered.">            if (!removal &amp;&amp; indexable) {</span>
<span class="pc bfc" id="L260" title="All 3 branches covered.">                switch (indexer.getIndexerType()) {</span>
                    case NAMEDFIELDS:
<span class="fc" id="L262">                        LOGGER.debug(</span>
                                &quot;Retrieving named fields for: {}, (may be cached) to index to {}...&quot;,
                                uri, indexer);
                        try  {
<span class="fc" id="L266">                            content = nfr.get();</span>
<span class="fc" id="L267">                            hasContent = true;</span>
<span class="nc" id="L268">                        } catch (final AbsentTransformPropertyException e) {</span>
<span class="nc" id="L269">                            LOGGER.error(&quot;Failed to retrieve indexable content:&quot;</span>
                                    + &quot;could not find transform property!&quot;);
<span class="nc" id="L271">                            hasContent = false;</span>
<span class="fc" id="L272">                        }</span>
<span class="nc" id="L273">                        break;</span>
                    case RDF:
<span class="fc" id="L275">                        LOGGER.debug(</span>
                                &quot;Retrieving RDF for: {}, (may be cached) to index to {}...&quot;,
                                uri, indexer);
<span class="fc" id="L278">                        content = rdfr.get();</span>
<span class="fc" id="L279">                        hasContent = true;</span>
<span class="fc" id="L280">                        break;</span>
                    default:
<span class="fc" id="L282">                        hasContent = true;</span>
                        break;
                }
            }

            try {
<span class="fc bfc" id="L288" title="All 2 branches covered.">                if (removal) {</span>
<span class="fc" id="L289">                    LOGGER.debug(</span>
                            &quot;Executing removal of: {} to indexer: {}...&quot;,
                            uri, indexer);
<span class="fc" id="L292">                    indexer.remove(uri);</span>
                } else {
<span class="fc bfc" id="L294" title="All 2 branches covered.">                    if (hasContent) {</span>
<span class="fc" id="L295">                        LOGGER.debug(</span>
                                &quot;Executing update of: {} to indexer: {}...&quot;,
                                uri, indexer);
<span class="fc" id="L298">                        indexer.update(uri, content);</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">                    } else if (indexable) {</span>
<span class="nc" id="L300">                        LOGGER.error(</span>
                                &quot;Received update for: {} but was unable to retrieve &quot;
                                        + &quot;content for update to indexer: {}!&quot;,
                                uri, indexer);
                    }
                }
<span class="nc" id="L306">            } catch (final Exception e) {</span>
<span class="nc" id="L307">                LOGGER.error(&quot;Error indexing {}: {}!&quot;, uri, e);</span>
<span class="fc" id="L308">            }</span>
<span class="fc" id="L309">        }</span>
<span class="fc" id="L310">    }</span>

    /**
     * Reindex all content in the repository by retrieving the root resource
     * and recursively reindexing all indexable child resources.
    **/
    public void reindex() {
<span class="fc" id="L317">        reindexed = new HashSet&lt;&gt;();</span>
<span class="fc" id="L318">        reindexURI( getRepositoryURL(), true );</span>
<span class="fc" id="L319">    }</span>

    /**
     * Reindex a resource (and optionally all of its children).
     * @param uri The resource URI to reindex.
     * @param recursive If true, also recursively reindex all children.
    **/
    public void reindex( final String uri, final boolean recursive ) {
<span class="nc" id="L327">        reindexed = new HashSet&lt;&gt;();</span>
<span class="nc" id="L328">        reindexURI( uri, recursive );</span>
<span class="nc" id="L329">    }</span>

    private void reindexURI( final String uri, final boolean recursive ) {
<span class="fc" id="L332">        LOGGER.debug(&quot;Reindexing {}, recursive: {}&quot;, uri, recursive);</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">        if ( !reindexed.contains(uri) ) {</span>
            // index() will check for indexable mixin
<span class="fc" id="L335">            index( uri, REINDEX_EVENT_TYPE );</span>
        }

        // prevent infinite recursion
<span class="fc" id="L339">        reindexed.add( uri );</span>

        // check for children (rdf should be cached...)
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if ( recursive ) {</span>
<span class="fc" id="L343">            final Supplier&lt;Model&gt; rdfr</span>
                = memoize(new RdfRetriever(uri, httpClient));
<span class="fc" id="L345">            final Model model = rdfr.get();</span>
<span class="fc" id="L346">            final NodeIterator children = model.listObjectsOfProperty( HAS_CHILD );</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">            while ( children.hasNext() ) {</span>
<span class="fc" id="L348">                final String child = children.nextNode().asResource().getURI();</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                if ( !reindexed.contains(child) ) {</span>
<span class="fc" id="L350">                    reindexURI( child, true );</span>
                }
<span class="fc" id="L352">            }</span>
        }
<span class="fc" id="L354">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>